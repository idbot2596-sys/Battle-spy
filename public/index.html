<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Big Map Battle</title>
    <style>
        body { margin: 0; overflow: hidden; background: #111; font-family: sans-serif; touch-action: none; }
        canvas { display: block; }
        #ui { position: absolute; top: 10px; left: 10px; color: white; pointer-events: none; }
        #shootBtn {
            position: absolute; bottom: 30px; right: 30px;
            width: 80px; height: 80px; background: rgba(231, 76, 60, 0.5);
            border-radius: 50%; border: 2px solid white; color: white; font-weight: bold;
            display: none; user-select: none;
        }
        #shootBtn:active { background: rgba(231, 76, 60, 0.9); }
    </style>
</head>
<body>
    <div id="ui">
        <div id="status">Connecting...</div>
        <div>Scores: <span id="scoreBoard"></span></div>
    </div>
    <div id="shootBtn">FIRE</div>
    <canvas id="gameCanvas"></canvas>

    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const shootBtn = document.getElementById('shootBtn');
        const statusDiv = document.getElementById('status');
        const scoreDiv = document.getElementById('scoreBoard');

        // Fullscreen Canvas
        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resize);
        resize();

        // Mobile Check
        if (/Android|iPhone|iPad/i.test(navigator.userAgent)) {
            shootBtn.style.display = 'flex';
            shootBtn.style.alignItems = 'center';
            shootBtn.style.justifyContent = 'center';
        }

        // Game Data
        let myId = null;
        let map = { width: 1000, height: 1000, obstacles: [] };
        let players = {};
        let projectiles = [];
        let inputs = { up: false, down: false, left: false, right: false };

        socket.on('connect', () => {
            statusDiv.innerText = "Connected! Waiting for map...";
            myId = socket.id;
        });

        socket.on('mapData', (data) => {
            map = data;
            statusDiv.innerText = "Playing";
        });

        socket.on('stateUpdate', (state) => {
            players = state.players;
            projectiles = state.projectiles;
            draw();
            updateScoreboard();
        });

        // --- INPUT HANDLING ---
        // PC
        window.addEventListener('keydown', e => setKey(e.code, true));
        window.addEventListener('keyup', e => setKey(e.code, false));
        function setKey(code, state) {
            if (code === 'KeyW') inputs.up = state;
            if (code === 'KeyS') inputs.down = state;
            if (code === 'KeyA') inputs.left = state;
            if (code === 'KeyD') inputs.right = state;
            socket.emit('movement', inputs);
        }
        
        // Mobile Joystick (Left side of screen)
        canvas.addEventListener('touchstart', handleTouch, {passive: false});
        canvas.addEventListener('touchmove', handleTouch, {passive: false});
        canvas.addEventListener('touchend', () => {
            inputs = { up: false, down: false, left: false, right: false };
            socket.emit('movement', inputs);
        });

        function handleTouch(e) {
            e.preventDefault();
            const touch = e.touches[0];
            const w = window.innerWidth;
            const h = window.innerHeight;

            // Only care about touches on the left half for movement
            if (touch.clientX < w / 2) {
                inputs.up = touch.clientY < h / 2 - 50;
                inputs.down = touch.clientY > h / 2 + 50;
                inputs.left = touch.clientX < w / 4 - 50;
                inputs.right = touch.clientX > w / 4 + 50;
                socket.emit('movement', inputs);
            }
        }

        // Shooting
        shootBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            socket.emit('shoot', Math.random() * Math.PI * 2); // Random direction for now on mobile
        });
        
        canvas.addEventListener('mousedown', (e) => {
            if (!players[myId]) return;
            const p = players[myId];
            // Calculate real angle using Camera Offset
            const camX = p.x - canvas.width / 2;
            const camY = p.y - canvas.height / 2;
            const mouseX = e.clientX + camX;
            const mouseY = e.clientY + camY;
            const angle = Math.atan2(mouseY - p.y, mouseX - p.x);
            socket.emit('shoot', angle);
        });

        // --- DRAWING SYSTEM (The Camera) ---
        function draw() {
            // 1. Clear Screen
            ctx.fillStyle = '#111';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const me = players[myId];
            if (!me) return; // Wait until we spawn

            // 2. Calculate Camera Position
            // We want 'me' to be in the middle of the screen
            const camX = me.x - canvas.width / 2;
            const camY = me.y - canvas.height / 2;

            ctx.save();
            ctx.translate(-camX, -camY); // Shift the whole world

            // 3. Draw World Borders
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 5;
            ctx.strokeRect(0, 0, map.width, map.height);

            // 4. Draw Grid (Helps see movement)
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let x = 0; x <= map.width; x += 100) { ctx.moveTo(x, 0); ctx.lineTo(x, map.height); }
            for (let y = 0; y <= map.height; y += 100) { ctx.moveTo(0, y); ctx.lineTo(map.width, y); }
            ctx.stroke();

            // 5. Draw Obstacles
            ctx.fillStyle = '#2ecc71'; // Green Trees
            map.obstacles.forEach(obs => {
                ctx.beginPath();
                ctx.arc(obs.x, obs.y, obs.r, 0, Math.PI * 2);
                ctx.fill();
            });

            // 6. Draw Players
            for (const id in players) {
                const p = players[id];
                ctx.beginPath();
                ctx.arc(p.x, p.y, 20, 0, Math.PI * 2);
                ctx.fillStyle = (id === myId) ? '#3498db' : '#e74c3c';
                ctx.fill();
                
                // Health Bar
                ctx.fillStyle = 'red';
                ctx.fillRect(p.x - 20, p.y - 35, 40, 5);
                ctx.fillStyle = '#0f0';
                ctx.fillRect(p.x - 20, p.y - 35, 40 * (p.hp / 100), 5);
            }

            // 7. Draw Projectiles
            ctx.fillStyle = '#f1c40f';
            projectiles.forEach(proj => {
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, 6, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.restore(); // Stop shifting
        }

        function updateScoreboard() {
            if (!players[myId]) return;
            scoreDiv.innerText = `Me: ${players[myId].score}`;
        }
    </script>
</body>
</html>
